这题和 309 Best Time to Buy and Sell Stock with Cooldown  有点类似，
但是限制条件变成了交易次数，这题我们也是需要找到关键状态才能求解

## 完全交易

当交易次数超过 prices.length / 2 的时候以为着我们每次可以盈利的交易都可以使用。

## 不完全交易

我们不能把所有盈利都用上的时候，需要找到一种合适交易方案

我们假设最后dp[i][j]为第i天最多交易j次的最优解,为了达到最大盈利，很明显我们最后一天的时候不会做买入的操作

所以最后一天时我们只可能是两种状况，卖出，或者啥都不做。

dp[i][j] = Max(dp[i - 1][j], dp[x][j - 1] + prices[i] - prices[x])

dp[i - 1][j] 为啥都不做的时候

dp[x][j - 1] + prices[i] - prices[x]为最后一天才卖出的时候，0 <= x < prices.length 第x天做交易



这里我们引入局部最优的思想来找最优解

### 局部最优

什么是局部最优，在这道题我们可以看做是，当

和 309 一样，我们还是会存在三种状态

- 持股 当天买了股票，或者之前买了股票
- 清仓 当天卖出股票叫做清仓
- 空仓 当天没有买卖，并且没有持股

分别设 dp_sell[i][j], dp_clear[i][j]m dp_empty[i][j], 为第 i 天，最多j次交易式，三种状态下的最优解，
我们只有在清仓的时候才会消耗掉一次交易次数

- 持股 , 前一天可能是三种情况，如果前一天是清仓或者空仓时，持股那一天需要消耗一次交易次数dp_sell[i][j] = Max(dp_sell[i - 1][j], dp_clear[i - 1][j - 1] - prices[i], dp_empty[i - 1][j - 1] - prices[i])
- 清仓，前一天只可能是持股 dp_clear[i][j] = dp_sell[i - 1][j - 1] + diff
- 空仓，前一天可能是清仓也可能是空仓 dp_empty[i][j] = Max(dp_empty[i-1][j], dp_clear[i-1][j])

因为要保证利益最大化，我最后一天的时候一定不会持股，所以我们只需要对比清仓时和空仓时的最优解即可

清仓的公式可以转化为

dp_clear[i][j] = Max(dp_clear[i-1][j-1] - prices[i], dp_empty[i-1][j-1] - prices[i]) + prices[i]

等价于



第一天也是只能有空仓和持股两种状态，所以我们需要从第二天开始统计
